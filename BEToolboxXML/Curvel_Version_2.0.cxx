// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "stdafx.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Curvel_Version_2.0.hxx"

// VerticalCurveDataType
// 

const VerticalCurveDataType::g1_type& VerticalCurveDataType::
g1 () const
{
  return this->g1_.get ();
}

VerticalCurveDataType::g1_type& VerticalCurveDataType::
g1 ()
{
  return this->g1_.get ();
}

void VerticalCurveDataType::
g1 (const g1_type& x)
{
  this->g1_.set (x);
}

const VerticalCurveDataType::g2_type& VerticalCurveDataType::
g2 () const
{
  return this->g2_.get ();
}

VerticalCurveDataType::g2_type& VerticalCurveDataType::
g2 ()
{
  return this->g2_.get ();
}

void VerticalCurveDataType::
g2 (const g2_type& x)
{
  this->g2_.set (x);
}

const VerticalCurveDataType::PVIStation_type& VerticalCurveDataType::
PVIStation () const
{
  return this->PVIStation_.get ();
}

VerticalCurveDataType::PVIStation_type& VerticalCurveDataType::
PVIStation ()
{
  return this->PVIStation_.get ();
}

void VerticalCurveDataType::
PVIStation (const PVIStation_type& x)
{
  this->PVIStation_.set (x);
}

void VerticalCurveDataType::
PVIStation (::std::auto_ptr< PVIStation_type > x)
{
  this->PVIStation_.set (x);
}

const VerticalCurveDataType::PVIElevation_type& VerticalCurveDataType::
PVIElevation () const
{
  return this->PVIElevation_.get ();
}

VerticalCurveDataType::PVIElevation_type& VerticalCurveDataType::
PVIElevation ()
{
  return this->PVIElevation_.get ();
}

void VerticalCurveDataType::
PVIElevation (const PVIElevation_type& x)
{
  this->PVIElevation_.set (x);
}

void VerticalCurveDataType::
PVIElevation (::std::auto_ptr< PVIElevation_type > x)
{
  this->PVIElevation_.set (x);
}

const VerticalCurveDataType::Length_type& VerticalCurveDataType::
Length () const
{
  return this->Length_.get ();
}

VerticalCurveDataType::Length_type& VerticalCurveDataType::
Length ()
{
  return this->Length_.get ();
}

void VerticalCurveDataType::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void VerticalCurveDataType::
Length (::std::auto_ptr< Length_type > x)
{
  this->Length_.set (x);
}

const VerticalCurveDataType::version_type& VerticalCurveDataType::
version () const
{
  return this->version_.get ();
}

VerticalCurveDataType::version_type VerticalCurveDataType::
version_default_value ()
{
  return version_type (1.0);
}


// SuperelevationDataType
// 

const SuperelevationDataType::ProfileGradeOffset_type& SuperelevationDataType::
ProfileGradeOffset () const
{
  return this->ProfileGradeOffset_.get ();
}

SuperelevationDataType::ProfileGradeOffset_type& SuperelevationDataType::
ProfileGradeOffset ()
{
  return this->ProfileGradeOffset_.get ();
}

void SuperelevationDataType::
ProfileGradeOffset (const ProfileGradeOffset_type& x)
{
  this->ProfileGradeOffset_.set (x);
}

void SuperelevationDataType::
ProfileGradeOffset (::std::auto_ptr< ProfileGradeOffset_type > x)
{
  this->ProfileGradeOffset_.set (x);
}

const SuperelevationDataType::CrownSlope_type& SuperelevationDataType::
CrownSlope () const
{
  return this->CrownSlope_.get ();
}

SuperelevationDataType::CrownSlope_type& SuperelevationDataType::
CrownSlope ()
{
  return this->CrownSlope_.get ();
}

void SuperelevationDataType::
CrownSlope (const CrownSlope_type& x)
{
  this->CrownSlope_.set (x);
}

void SuperelevationDataType::
CrownSlope (::std::auto_ptr< CrownSlope_type > x)
{
  this->CrownSlope_.set (x);
}

const SuperelevationDataType::version_type& SuperelevationDataType::
version () const
{
  return this->version_.get ();
}

SuperelevationDataType::version_type SuperelevationDataType::
version_default_value ()
{
  return version_type (2.0);
}


// CrownSlopeType
// 

const CrownSlopeType::SuperelevationProfilePoint_sequence& CrownSlopeType::
SuperelevationProfilePoint () const
{
  return this->SuperelevationProfilePoint_;
}

CrownSlopeType::SuperelevationProfilePoint_sequence& CrownSlopeType::
SuperelevationProfilePoint ()
{
  return this->SuperelevationProfilePoint_;
}

void CrownSlopeType::
SuperelevationProfilePoint (const SuperelevationProfilePoint_sequence& s)
{
  this->SuperelevationProfilePoint_ = s;
}

const CrownSlopeType::version_type& CrownSlopeType::
version () const
{
  return this->version_.get ();
}

CrownSlopeType::version_type CrownSlopeType::
version_default_value ()
{
  return version_type (1.0);
}


// SuperelevationProfilePointType
// 

const SuperelevationProfilePointType::Station_type& SuperelevationProfilePointType::
Station () const
{
  return this->Station_.get ();
}

SuperelevationProfilePointType::Station_type& SuperelevationProfilePointType::
Station ()
{
  return this->Station_.get ();
}

void SuperelevationProfilePointType::
Station (const Station_type& x)
{
  this->Station_.set (x);
}

void SuperelevationProfilePointType::
Station (::std::auto_ptr< Station_type > x)
{
  this->Station_.set (x);
}

const SuperelevationProfilePointType::LeftSlope_type& SuperelevationProfilePointType::
LeftSlope () const
{
  return this->LeftSlope_.get ();
}

SuperelevationProfilePointType::LeftSlope_type& SuperelevationProfilePointType::
LeftSlope ()
{
  return this->LeftSlope_.get ();
}

void SuperelevationProfilePointType::
LeftSlope (const LeftSlope_type& x)
{
  this->LeftSlope_.set (x);
}

const SuperelevationProfilePointType::RightSlope_type& SuperelevationProfilePointType::
RightSlope () const
{
  return this->RightSlope_.get ();
}

SuperelevationProfilePointType::RightSlope_type& SuperelevationProfilePointType::
RightSlope ()
{
  return this->RightSlope_.get ();
}

void SuperelevationProfilePointType::
RightSlope (const RightSlope_type& x)
{
  this->RightSlope_.set (x);
}

const SuperelevationProfilePointType::version_type& SuperelevationProfilePointType::
version () const
{
  return this->version_.get ();
}

SuperelevationProfilePointType::version_type SuperelevationProfilePointType::
version_default_value ()
{
  return version_type (2.0);
}


// IndividualStationsType
// 

const IndividualStationsType::IndividualStation_sequence& IndividualStationsType::
IndividualStation () const
{
  return this->IndividualStation_;
}

IndividualStationsType::IndividualStation_sequence& IndividualStationsType::
IndividualStation ()
{
  return this->IndividualStation_;
}

void IndividualStationsType::
IndividualStation (const IndividualStation_sequence& s)
{
  this->IndividualStation_ = s;
}

const IndividualStationsType::version_type& IndividualStationsType::
version () const
{
  return this->version_.get ();
}

IndividualStationsType::version_type IndividualStationsType::
version_default_value ()
{
  return version_type (2.0);
}


// IndividualStationType
// 

const IndividualStationType::Station_type& IndividualStationType::
Station () const
{
  return this->Station_.get ();
}

IndividualStationType::Station_type& IndividualStationType::
Station ()
{
  return this->Station_.get ();
}

void IndividualStationType::
Station (const Station_type& x)
{
  this->Station_.set (x);
}

void IndividualStationType::
Station (::std::auto_ptr< Station_type > x)
{
  this->Station_.set (x);
}

const IndividualStationType::Offset_type& IndividualStationType::
Offset () const
{
  return this->Offset_.get ();
}

IndividualStationType::Offset_type& IndividualStationType::
Offset ()
{
  return this->Offset_.get ();
}

void IndividualStationType::
Offset (const Offset_type& x)
{
  this->Offset_.set (x);
}

void IndividualStationType::
Offset (::std::auto_ptr< Offset_type > x)
{
  this->Offset_.set (x);
}

const IndividualStationType::version_type& IndividualStationType::
version () const
{
  return this->version_.get ();
}

IndividualStationType::version_type IndividualStationType::
version_default_value ()
{
  return version_type (1.0);
}


// StationRangesType
// 

const StationRangesType::StationRange_sequence& StationRangesType::
StationRange () const
{
  return this->StationRange_;
}

StationRangesType::StationRange_sequence& StationRangesType::
StationRange ()
{
  return this->StationRange_;
}

void StationRangesType::
StationRange (const StationRange_sequence& s)
{
  this->StationRange_ = s;
}

const StationRangesType::version_type& StationRangesType::
version () const
{
  return this->version_.get ();
}

StationRangesType::version_type StationRangesType::
version_default_value ()
{
  return version_type (2.0);
}


// StationRangeType
// 

const StationRangeType::StartStation_type& StationRangeType::
StartStation () const
{
  return this->StartStation_.get ();
}

StationRangeType::StartStation_type& StationRangeType::
StartStation ()
{
  return this->StartStation_.get ();
}

void StationRangeType::
StartStation (const StartStation_type& x)
{
  this->StartStation_.set (x);
}

void StationRangeType::
StartStation (::std::auto_ptr< StartStation_type > x)
{
  this->StartStation_.set (x);
}

const StationRangeType::EndStation_type& StationRangeType::
EndStation () const
{
  return this->EndStation_.get ();
}

StationRangeType::EndStation_type& StationRangeType::
EndStation ()
{
  return this->EndStation_.get ();
}

void StationRangeType::
EndStation (const EndStation_type& x)
{
  this->EndStation_.set (x);
}

void StationRangeType::
EndStation (::std::auto_ptr< EndStation_type > x)
{
  this->EndStation_.set (x);
}

const StationRangeType::NumSpaces_type& StationRangeType::
NumSpaces () const
{
  return this->NumSpaces_.get ();
}

StationRangeType::NumSpaces_type& StationRangeType::
NumSpaces ()
{
  return this->NumSpaces_.get ();
}

void StationRangeType::
NumSpaces (const NumSpaces_type& x)
{
  this->NumSpaces_.set (x);
}

const StationRangeType::Offset_type& StationRangeType::
Offset () const
{
  return this->Offset_.get ();
}

StationRangeType::Offset_type& StationRangeType::
Offset ()
{
  return this->Offset_.get ();
}

void StationRangeType::
Offset (const Offset_type& x)
{
  this->Offset_.set (x);
}

void StationRangeType::
Offset (::std::auto_ptr< Offset_type > x)
{
  this->Offset_.set (x);
}

const StationRangeType::version_type& StationRangeType::
version () const
{
  return this->version_.get ();
}

StationRangeType::version_type StationRangeType::
version_default_value ()
{
  return version_type (1.0);
}


// SkewLinesType
// 

const SkewLinesType::SkewLine_sequence& SkewLinesType::
SkewLine () const
{
  return this->SkewLine_;
}

SkewLinesType::SkewLine_sequence& SkewLinesType::
SkewLine ()
{
  return this->SkewLine_;
}

void SkewLinesType::
SkewLine (const SkewLine_sequence& s)
{
  this->SkewLine_ = s;
}

const SkewLinesType::version_type& SkewLinesType::
version () const
{
  return this->version_.get ();
}

SkewLinesType::version_type SkewLinesType::
version_default_value ()
{
  return version_type (2.0);
}


// OffsetType
// 

OffsetType::
OffsetType (value v)
: ::xml_schema::string (_xsd_OffsetType_literals_[v])
{
}

OffsetType::
OffsetType (const wchar_t* v)
: ::xml_schema::string (v)
{
}

OffsetType::
OffsetType (const ::std::wstring& v)
: ::xml_schema::string (v)
{
}

OffsetType::
OffsetType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

OffsetType::
OffsetType (const OffsetType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

OffsetType& OffsetType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_OffsetType_literals_[v]);

  return *this;
}


// SkewAngleType
// 


// SkewLineType
// 

const SkewLineType::Station_type& SkewLineType::
Station () const
{
  return this->Station_.get ();
}

SkewLineType::Station_type& SkewLineType::
Station ()
{
  return this->Station_.get ();
}

void SkewLineType::
Station (const Station_type& x)
{
  this->Station_.set (x);
}

void SkewLineType::
Station (::std::auto_ptr< Station_type > x)
{
  this->Station_.set (x);
}

const SkewLineType::OffsetType_type& SkewLineType::
OffsetType () const
{
  return this->OffsetType_.get ();
}

SkewLineType::OffsetType_type& SkewLineType::
OffsetType ()
{
  return this->OffsetType_.get ();
}

void SkewLineType::
OffsetType (const OffsetType_type& x)
{
  this->OffsetType_.set (x);
}

void SkewLineType::
OffsetType (::std::auto_ptr< OffsetType_type > x)
{
  this->OffsetType_.set (x);
}

const SkewLineType::Offset_type& SkewLineType::
Offset () const
{
  return this->Offset_.get ();
}

SkewLineType::Offset_type& SkewLineType::
Offset ()
{
  return this->Offset_.get ();
}

void SkewLineType::
Offset (const Offset_type& x)
{
  this->Offset_.set (x);
}

void SkewLineType::
Offset (::std::auto_ptr< Offset_type > x)
{
  this->Offset_.set (x);
}

const SkewLineType::SkewAngle_type& SkewLineType::
SkewAngle () const
{
  return this->SkewAngle_.get ();
}

SkewLineType::SkewAngle_type& SkewLineType::
SkewAngle ()
{
  return this->SkewAngle_.get ();
}

void SkewLineType::
SkewAngle (const SkewAngle_type& x)
{
  this->SkewAngle_.set (x);
}

void SkewLineType::
SkewAngle (::std::auto_ptr< SkewAngle_type > x)
{
  this->SkewAngle_.set (x);
}

const SkewLineType::Radius_type& SkewLineType::
Radius () const
{
  return this->Radius_.get ();
}

SkewLineType::Radius_type& SkewLineType::
Radius ()
{
  return this->Radius_.get ();
}

void SkewLineType::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void SkewLineType::
Radius (::std::auto_ptr< Radius_type > x)
{
  this->Radius_.set (x);
}

const SkewLineType::CrownOffset_type& SkewLineType::
CrownOffset () const
{
  return this->CrownOffset_.get ();
}

SkewLineType::CrownOffset_type& SkewLineType::
CrownOffset ()
{
  return this->CrownOffset_.get ();
}

void SkewLineType::
CrownOffset (const CrownOffset_type& x)
{
  this->CrownOffset_.set (x);
}

void SkewLineType::
CrownOffset (::std::auto_ptr< CrownOffset_type > x)
{
  this->CrownOffset_.set (x);
}

const SkewLineType::version_type& SkewLineType::
version () const
{
  return this->version_.get ();
}

SkewLineType::version_type SkewLineType::
version_default_value ()
{
  return version_type (2.0);
}


// Curvel
// 

const Curvel::UnitsDeclaration_optional& Curvel::
UnitsDeclaration () const
{
  return this->UnitsDeclaration_;
}

Curvel::UnitsDeclaration_optional& Curvel::
UnitsDeclaration ()
{
  return this->UnitsDeclaration_;
}

void Curvel::
UnitsDeclaration (const UnitsDeclaration_type& x)
{
  this->UnitsDeclaration_.set (x);
}

void Curvel::
UnitsDeclaration (const UnitsDeclaration_optional& x)
{
  this->UnitsDeclaration_ = x;
}

void Curvel::
UnitsDeclaration (::std::auto_ptr< UnitsDeclaration_type > x)
{
  this->UnitsDeclaration_.set (x);
}

const Curvel::VerticalCurveData_type& Curvel::
VerticalCurveData () const
{
  return this->VerticalCurveData_.get ();
}

Curvel::VerticalCurveData_type& Curvel::
VerticalCurveData ()
{
  return this->VerticalCurveData_.get ();
}

void Curvel::
VerticalCurveData (const VerticalCurveData_type& x)
{
  this->VerticalCurveData_.set (x);
}

void Curvel::
VerticalCurveData (::std::auto_ptr< VerticalCurveData_type > x)
{
  this->VerticalCurveData_.set (x);
}

const Curvel::SuperelevationData_optional& Curvel::
SuperelevationData () const
{
  return this->SuperelevationData_;
}

Curvel::SuperelevationData_optional& Curvel::
SuperelevationData ()
{
  return this->SuperelevationData_;
}

void Curvel::
SuperelevationData (const SuperelevationData_type& x)
{
  this->SuperelevationData_.set (x);
}

void Curvel::
SuperelevationData (const SuperelevationData_optional& x)
{
  this->SuperelevationData_ = x;
}

void Curvel::
SuperelevationData (::std::auto_ptr< SuperelevationData_type > x)
{
  this->SuperelevationData_.set (x);
}

const Curvel::IndividualStations_optional& Curvel::
IndividualStations () const
{
  return this->IndividualStations_;
}

Curvel::IndividualStations_optional& Curvel::
IndividualStations ()
{
  return this->IndividualStations_;
}

void Curvel::
IndividualStations (const IndividualStations_type& x)
{
  this->IndividualStations_.set (x);
}

void Curvel::
IndividualStations (const IndividualStations_optional& x)
{
  this->IndividualStations_ = x;
}

void Curvel::
IndividualStations (::std::auto_ptr< IndividualStations_type > x)
{
  this->IndividualStations_.set (x);
}

const Curvel::StationRanges_optional& Curvel::
StationRanges () const
{
  return this->StationRanges_;
}

Curvel::StationRanges_optional& Curvel::
StationRanges ()
{
  return this->StationRanges_;
}

void Curvel::
StationRanges (const StationRanges_type& x)
{
  this->StationRanges_.set (x);
}

void Curvel::
StationRanges (const StationRanges_optional& x)
{
  this->StationRanges_ = x;
}

void Curvel::
StationRanges (::std::auto_ptr< StationRanges_type > x)
{
  this->StationRanges_.set (x);
}

const Curvel::SkewLines_optional& Curvel::
SkewLines () const
{
  return this->SkewLines_;
}

Curvel::SkewLines_optional& Curvel::
SkewLines ()
{
  return this->SkewLines_;
}

void Curvel::
SkewLines (const SkewLines_type& x)
{
  this->SkewLines_.set (x);
}

void Curvel::
SkewLines (const SkewLines_optional& x)
{
  this->SkewLines_ = x;
}

void Curvel::
SkewLines (::std::auto_ptr< SkewLines_type > x)
{
  this->SkewLines_.set (x);
}

const Curvel::version_type& Curvel::
version () const
{
  return this->version_.get ();
}

Curvel::version_type Curvel::
version_default_value ()
{
  return version_type (2.0);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// VerticalCurveDataType
//

VerticalCurveDataType::
VerticalCurveDataType (const g1_type& g1,
                       const g2_type& g2,
                       const PVIStation_type& PVIStation,
                       const PVIElevation_type& PVIElevation,
                       const Length_type& Length)
: ::xml_schema::type (),
  g1_ (g1, ::xml_schema::flags (), this),
  g2_ (g2, ::xml_schema::flags (), this),
  PVIStation_ (PVIStation, ::xml_schema::flags (), this),
  PVIElevation_ (PVIElevation, ::xml_schema::flags (), this),
  Length_ (Length, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

VerticalCurveDataType::
VerticalCurveDataType (const g1_type& g1,
                       const g2_type& g2,
                       ::std::auto_ptr< PVIStation_type >& PVIStation,
                       ::std::auto_ptr< PVIElevation_type >& PVIElevation,
                       ::std::auto_ptr< Length_type >& Length)
: ::xml_schema::type (),
  g1_ (g1, ::xml_schema::flags (), this),
  g2_ (g2, ::xml_schema::flags (), this),
  PVIStation_ (PVIStation, ::xml_schema::flags (), this),
  PVIElevation_ (PVIElevation, ::xml_schema::flags (), this),
  Length_ (Length, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

VerticalCurveDataType::
VerticalCurveDataType (const VerticalCurveDataType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  g1_ (x.g1_, f, this),
  g2_ (x.g2_, f, this),
  PVIStation_ (x.PVIStation_, f, this),
  PVIElevation_ (x.PVIElevation_, f, this),
  Length_ (x.Length_, f, this),
  version_ (x.version_, f, this)
{
}

VerticalCurveDataType::
VerticalCurveDataType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  g1_ (f, this),
  g2_ (f, this),
  PVIStation_ (f, this),
  PVIElevation_ (f, this),
  Length_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void VerticalCurveDataType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // g1
    //
    if (n.name () == L"g1" && n.namespace_ ().empty ())
    {
      if (!g1_.present ())
      {
        this->g1_.set (g1_traits::create (i, f, this));
        continue;
      }
    }

    // g2
    //
    if (n.name () == L"g2" && n.namespace_ ().empty ())
    {
      if (!g2_.present ())
      {
        this->g2_.set (g2_traits::create (i, f, this));
        continue;
      }
    }

    // PVIStation
    //
    if (n.name () == L"PVIStation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PVIStation_type > r (
        PVIStation_traits::create (i, f, this));

      if (!PVIStation_.present ())
      {
        this->PVIStation_.set (r);
        continue;
      }
    }

    // PVIElevation
    //
    if (n.name () == L"PVIElevation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PVIElevation_type > r (
        PVIElevation_traits::create (i, f, this));

      if (!PVIElevation_.present ())
      {
        this->PVIElevation_.set (r);
        continue;
      }
    }

    // Length
    //
    if (n.name () == L"Length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Length_type > r (
        Length_traits::create (i, f, this));

      if (!Length_.present ())
      {
        this->Length_.set (r);
        continue;
      }
    }

    break;
  }

  if (!g1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"g1",
      L"");
  }

  if (!g2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"g2",
      L"");
  }

  if (!PVIStation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"PVIStation",
      L"");
  }

  if (!PVIElevation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"PVIElevation",
      L"");
  }

  if (!Length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Length",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

VerticalCurveDataType* VerticalCurveDataType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VerticalCurveDataType (*this, f, c);
}

VerticalCurveDataType::
~VerticalCurveDataType ()
{
}

// SuperelevationDataType
//

SuperelevationDataType::
SuperelevationDataType (const ProfileGradeOffset_type& ProfileGradeOffset,
                        const CrownSlope_type& CrownSlope)
: ::xml_schema::type (),
  ProfileGradeOffset_ (ProfileGradeOffset, ::xml_schema::flags (), this),
  CrownSlope_ (CrownSlope, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SuperelevationDataType::
SuperelevationDataType (::std::auto_ptr< ProfileGradeOffset_type >& ProfileGradeOffset,
                        ::std::auto_ptr< CrownSlope_type >& CrownSlope)
: ::xml_schema::type (),
  ProfileGradeOffset_ (ProfileGradeOffset, ::xml_schema::flags (), this),
  CrownSlope_ (CrownSlope, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SuperelevationDataType::
SuperelevationDataType (const SuperelevationDataType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ProfileGradeOffset_ (x.ProfileGradeOffset_, f, this),
  CrownSlope_ (x.CrownSlope_, f, this),
  version_ (x.version_, f, this)
{
}

SuperelevationDataType::
SuperelevationDataType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ProfileGradeOffset_ (f, this),
  CrownSlope_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void SuperelevationDataType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // ProfileGradeOffset
    //
    if (n.name () == L"ProfileGradeOffset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ProfileGradeOffset_type > r (
        ProfileGradeOffset_traits::create (i, f, this));

      if (!ProfileGradeOffset_.present ())
      {
        this->ProfileGradeOffset_.set (r);
        continue;
      }
    }

    // CrownSlope
    //
    if (n.name () == L"CrownSlope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CrownSlope_type > r (
        CrownSlope_traits::create (i, f, this));

      if (!CrownSlope_.present ())
      {
        this->CrownSlope_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ProfileGradeOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"ProfileGradeOffset",
      L"");
  }

  if (!CrownSlope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"CrownSlope",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

SuperelevationDataType* SuperelevationDataType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SuperelevationDataType (*this, f, c);
}

SuperelevationDataType::
~SuperelevationDataType ()
{
}

// CrownSlopeType
//

CrownSlopeType::
CrownSlopeType ()
: ::xml_schema::type (),
  SuperelevationProfilePoint_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

CrownSlopeType::
CrownSlopeType (const CrownSlopeType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SuperelevationProfilePoint_ (x.SuperelevationProfilePoint_, f, this),
  version_ (x.version_, f, this)
{
}

CrownSlopeType::
CrownSlopeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SuperelevationProfilePoint_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void CrownSlopeType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // SuperelevationProfilePoint
    //
    if (n.name () == L"SuperelevationProfilePoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SuperelevationProfilePoint_type > r (
        SuperelevationProfilePoint_traits::create (i, f, this));

      this->SuperelevationProfilePoint_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

CrownSlopeType* CrownSlopeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CrownSlopeType (*this, f, c);
}

CrownSlopeType::
~CrownSlopeType ()
{
}

// SuperelevationProfilePointType
//

SuperelevationProfilePointType::
SuperelevationProfilePointType (const Station_type& Station,
                                const LeftSlope_type& LeftSlope,
                                const RightSlope_type& RightSlope)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  LeftSlope_ (LeftSlope, ::xml_schema::flags (), this),
  RightSlope_ (RightSlope, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SuperelevationProfilePointType::
SuperelevationProfilePointType (::std::auto_ptr< Station_type >& Station,
                                const LeftSlope_type& LeftSlope,
                                const RightSlope_type& RightSlope)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  LeftSlope_ (LeftSlope, ::xml_schema::flags (), this),
  RightSlope_ (RightSlope, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SuperelevationProfilePointType::
SuperelevationProfilePointType (const SuperelevationProfilePointType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Station_ (x.Station_, f, this),
  LeftSlope_ (x.LeftSlope_, f, this),
  RightSlope_ (x.RightSlope_, f, this),
  version_ (x.version_, f, this)
{
}

SuperelevationProfilePointType::
SuperelevationProfilePointType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Station_ (f, this),
  LeftSlope_ (f, this),
  RightSlope_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void SuperelevationProfilePointType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // Station
    //
    if (n.name () == L"Station" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Station_type > r (
        Station_traits::create (i, f, this));

      if (!Station_.present ())
      {
        this->Station_.set (r);
        continue;
      }
    }

    // LeftSlope
    //
    if (n.name () == L"LeftSlope" && n.namespace_ ().empty ())
    {
      if (!LeftSlope_.present ())
      {
        this->LeftSlope_.set (LeftSlope_traits::create (i, f, this));
        continue;
      }
    }

    // RightSlope
    //
    if (n.name () == L"RightSlope" && n.namespace_ ().empty ())
    {
      if (!RightSlope_.present ())
      {
        this->RightSlope_.set (RightSlope_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Station_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Station",
      L"");
  }

  if (!LeftSlope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"LeftSlope",
      L"");
  }

  if (!RightSlope_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"RightSlope",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

SuperelevationProfilePointType* SuperelevationProfilePointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SuperelevationProfilePointType (*this, f, c);
}

SuperelevationProfilePointType::
~SuperelevationProfilePointType ()
{
}

// IndividualStationsType
//

IndividualStationsType::
IndividualStationsType ()
: ::xml_schema::type (),
  IndividualStation_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

IndividualStationsType::
IndividualStationsType (const IndividualStationsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IndividualStation_ (x.IndividualStation_, f, this),
  version_ (x.version_, f, this)
{
}

IndividualStationsType::
IndividualStationsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IndividualStation_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void IndividualStationsType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // IndividualStation
    //
    if (n.name () == L"IndividualStation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IndividualStation_type > r (
        IndividualStation_traits::create (i, f, this));

      this->IndividualStation_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

IndividualStationsType* IndividualStationsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IndividualStationsType (*this, f, c);
}

IndividualStationsType::
~IndividualStationsType ()
{
}

// IndividualStationType
//

IndividualStationType::
IndividualStationType (const Station_type& Station,
                       const Offset_type& Offset)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

IndividualStationType::
IndividualStationType (::std::auto_ptr< Station_type >& Station,
                       ::std::auto_ptr< Offset_type >& Offset)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

IndividualStationType::
IndividualStationType (const IndividualStationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Station_ (x.Station_, f, this),
  Offset_ (x.Offset_, f, this),
  version_ (x.version_, f, this)
{
}

IndividualStationType::
IndividualStationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Station_ (f, this),
  Offset_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void IndividualStationType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // Station
    //
    if (n.name () == L"Station" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Station_type > r (
        Station_traits::create (i, f, this));

      if (!Station_.present ())
      {
        this->Station_.set (r);
        continue;
      }
    }

    // Offset
    //
    if (n.name () == L"Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Offset_type > r (
        Offset_traits::create (i, f, this));

      if (!Offset_.present ())
      {
        this->Offset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Station_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Station",
      L"");
  }

  if (!Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Offset",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

IndividualStationType* IndividualStationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IndividualStationType (*this, f, c);
}

IndividualStationType::
~IndividualStationType ()
{
}

// StationRangesType
//

StationRangesType::
StationRangesType ()
: ::xml_schema::type (),
  StationRange_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

StationRangesType::
StationRangesType (const StationRangesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  StationRange_ (x.StationRange_, f, this),
  version_ (x.version_, f, this)
{
}

StationRangesType::
StationRangesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  StationRange_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void StationRangesType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // StationRange
    //
    if (n.name () == L"StationRange" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< StationRange_type > r (
        StationRange_traits::create (i, f, this));

      this->StationRange_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

StationRangesType* StationRangesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StationRangesType (*this, f, c);
}

StationRangesType::
~StationRangesType ()
{
}

// StationRangeType
//

StationRangeType::
StationRangeType (const StartStation_type& StartStation,
                  const EndStation_type& EndStation,
                  const NumSpaces_type& NumSpaces,
                  const Offset_type& Offset)
: ::xml_schema::type (),
  StartStation_ (StartStation, ::xml_schema::flags (), this),
  EndStation_ (EndStation, ::xml_schema::flags (), this),
  NumSpaces_ (NumSpaces, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

StationRangeType::
StationRangeType (::std::auto_ptr< StartStation_type >& StartStation,
                  ::std::auto_ptr< EndStation_type >& EndStation,
                  const NumSpaces_type& NumSpaces,
                  ::std::auto_ptr< Offset_type >& Offset)
: ::xml_schema::type (),
  StartStation_ (StartStation, ::xml_schema::flags (), this),
  EndStation_ (EndStation, ::xml_schema::flags (), this),
  NumSpaces_ (NumSpaces, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

StationRangeType::
StationRangeType (const StationRangeType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  StartStation_ (x.StartStation_, f, this),
  EndStation_ (x.EndStation_, f, this),
  NumSpaces_ (x.NumSpaces_, f, this),
  Offset_ (x.Offset_, f, this),
  version_ (x.version_, f, this)
{
}

StationRangeType::
StationRangeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  StartStation_ (f, this),
  EndStation_ (f, this),
  NumSpaces_ (f, this),
  Offset_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void StationRangeType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // StartStation
    //
    if (n.name () == L"StartStation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< StartStation_type > r (
        StartStation_traits::create (i, f, this));

      if (!StartStation_.present ())
      {
        this->StartStation_.set (r);
        continue;
      }
    }

    // EndStation
    //
    if (n.name () == L"EndStation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EndStation_type > r (
        EndStation_traits::create (i, f, this));

      if (!EndStation_.present ())
      {
        this->EndStation_.set (r);
        continue;
      }
    }

    // NumSpaces
    //
    if (n.name () == L"NumSpaces" && n.namespace_ ().empty ())
    {
      if (!NumSpaces_.present ())
      {
        this->NumSpaces_.set (NumSpaces_traits::create (i, f, this));
        continue;
      }
    }

    // Offset
    //
    if (n.name () == L"Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Offset_type > r (
        Offset_traits::create (i, f, this));

      if (!Offset_.present ())
      {
        this->Offset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!StartStation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"StartStation",
      L"");
  }

  if (!EndStation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"EndStation",
      L"");
  }

  if (!NumSpaces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"NumSpaces",
      L"");
  }

  if (!Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Offset",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

StationRangeType* StationRangeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StationRangeType (*this, f, c);
}

StationRangeType::
~StationRangeType ()
{
}

// SkewLinesType
//

SkewLinesType::
SkewLinesType ()
: ::xml_schema::type (),
  SkewLine_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SkewLinesType::
SkewLinesType (const SkewLinesType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SkewLine_ (x.SkewLine_, f, this),
  version_ (x.version_, f, this)
{
}

SkewLinesType::
SkewLinesType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SkewLine_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void SkewLinesType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // SkewLine
    //
    if (n.name () == L"SkewLine" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SkewLine_type > r (
        SkewLine_traits::create (i, f, this));

      this->SkewLine_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

SkewLinesType* SkewLinesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SkewLinesType (*this, f, c);
}

SkewLinesType::
~SkewLinesType ()
{
}

// OffsetType
//

OffsetType::
OffsetType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_OffsetType_convert ();
}

OffsetType::
OffsetType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_OffsetType_convert ();
}

OffsetType::
OffsetType (const ::std::wstring& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_OffsetType_convert ();
}

OffsetType* OffsetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OffsetType (*this, f, c);
}

OffsetType::value OffsetType::
_xsd_OffsetType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_OffsetType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_OffsetType_indexes_,
                    _xsd_OffsetType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_OffsetType_indexes_ + 2 || _xsd_OffsetType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
  }

  return *i;
}

const wchar_t* const OffsetType::
_xsd_OffsetType_literals_[2] =
{
  L"RadialFromCrownLine",
  L"AlongSkewFromLLine"
};

const OffsetType::value OffsetType::
_xsd_OffsetType_indexes_[2] =
{
  ::OffsetType::AlongSkewFromLLine,
  ::OffsetType::RadialFromCrownLine
};

// SkewAngleType
//

SkewAngleType::
SkewAngleType ()
: ::xml_schema::string ()
{
}

SkewAngleType::
SkewAngleType (const wchar_t* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

SkewAngleType::
SkewAngleType (const ::std::wstring& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

SkewAngleType::
SkewAngleType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

SkewAngleType::
SkewAngleType (const SkewAngleType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SkewAngleType::
SkewAngleType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SkewAngleType::
SkewAngleType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SkewAngleType::
SkewAngleType (const ::std::wstring& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SkewAngleType* SkewAngleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SkewAngleType (*this, f, c);
}

SkewAngleType::
~SkewAngleType ()
{
}

// SkewLineType
//

SkewLineType::
SkewLineType (const Station_type& Station,
              const OffsetType_type& OffsetType,
              const Offset_type& Offset,
              const SkewAngle_type& SkewAngle,
              const Radius_type& Radius,
              const CrownOffset_type& CrownOffset)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  OffsetType_ (OffsetType, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  SkewAngle_ (SkewAngle, ::xml_schema::flags (), this),
  Radius_ (Radius, ::xml_schema::flags (), this),
  CrownOffset_ (CrownOffset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SkewLineType::
SkewLineType (::std::auto_ptr< Station_type >& Station,
              const OffsetType_type& OffsetType,
              ::std::auto_ptr< Offset_type >& Offset,
              const SkewAngle_type& SkewAngle,
              ::std::auto_ptr< Radius_type >& Radius,
              ::std::auto_ptr< CrownOffset_type >& CrownOffset)
: ::xml_schema::type (),
  Station_ (Station, ::xml_schema::flags (), this),
  OffsetType_ (OffsetType, ::xml_schema::flags (), this),
  Offset_ (Offset, ::xml_schema::flags (), this),
  SkewAngle_ (SkewAngle, ::xml_schema::flags (), this),
  Radius_ (Radius, ::xml_schema::flags (), this),
  CrownOffset_ (CrownOffset, ::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

SkewLineType::
SkewLineType (const SkewLineType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Station_ (x.Station_, f, this),
  OffsetType_ (x.OffsetType_, f, this),
  Offset_ (x.Offset_, f, this),
  SkewAngle_ (x.SkewAngle_, f, this),
  Radius_ (x.Radius_, f, this),
  CrownOffset_ (x.CrownOffset_, f, this),
  version_ (x.version_, f, this)
{
}

SkewLineType::
SkewLineType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Station_ (f, this),
  OffsetType_ (f, this),
  Offset_ (f, this),
  SkewAngle_ (f, this),
  Radius_ (f, this),
  CrownOffset_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void SkewLineType::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // Station
    //
    if (n.name () == L"Station" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Station_type > r (
        Station_traits::create (i, f, this));

      if (!Station_.present ())
      {
        this->Station_.set (r);
        continue;
      }
    }

    // OffsetType
    //
    if (n.name () == L"OffsetType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OffsetType_type > r (
        OffsetType_traits::create (i, f, this));

      if (!OffsetType_.present ())
      {
        this->OffsetType_.set (r);
        continue;
      }
    }

    // Offset
    //
    if (n.name () == L"Offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Offset_type > r (
        Offset_traits::create (i, f, this));

      if (!Offset_.present ())
      {
        this->Offset_.set (r);
        continue;
      }
    }

    // SkewAngle
    //
    if (n.name () == L"SkewAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SkewAngle_type > r (
        SkewAngle_traits::create (i, f, this));

      if (!SkewAngle_.present ())
      {
        this->SkewAngle_.set (r);
        continue;
      }
    }

    // Radius
    //
    if (n.name () == L"Radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Radius_type > r (
        Radius_traits::create (i, f, this));

      if (!Radius_.present ())
      {
        this->Radius_.set (r);
        continue;
      }
    }

    // CrownOffset
    //
    if (n.name () == L"CrownOffset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CrownOffset_type > r (
        CrownOffset_traits::create (i, f, this));

      if (!CrownOffset_.present ())
      {
        this->CrownOffset_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Station_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Station",
      L"");
  }

  if (!OffsetType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"OffsetType",
      L"");
  }

  if (!Offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Offset",
      L"");
  }

  if (!SkewAngle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"SkewAngle",
      L"");
  }

  if (!Radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"Radius",
      L"");
  }

  if (!CrownOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"CrownOffset",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

SkewLineType* SkewLineType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SkewLineType (*this, f, c);
}

SkewLineType::
~SkewLineType ()
{
}

// Curvel
//

Curvel::
Curvel (const VerticalCurveData_type& VerticalCurveData)
: ::xml_schema::type (),
  UnitsDeclaration_ (::xml_schema::flags (), this),
  VerticalCurveData_ (VerticalCurveData, ::xml_schema::flags (), this),
  SuperelevationData_ (::xml_schema::flags (), this),
  IndividualStations_ (::xml_schema::flags (), this),
  StationRanges_ (::xml_schema::flags (), this),
  SkewLines_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

Curvel::
Curvel (::std::auto_ptr< VerticalCurveData_type >& VerticalCurveData)
: ::xml_schema::type (),
  UnitsDeclaration_ (::xml_schema::flags (), this),
  VerticalCurveData_ (VerticalCurveData, ::xml_schema::flags (), this),
  SuperelevationData_ (::xml_schema::flags (), this),
  IndividualStations_ (::xml_schema::flags (), this),
  StationRanges_ (::xml_schema::flags (), this),
  SkewLines_ (::xml_schema::flags (), this),
  version_ (version_default_value (), ::xml_schema::flags (), this)
{
}

Curvel::
Curvel (const Curvel& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  UnitsDeclaration_ (x.UnitsDeclaration_, f, this),
  VerticalCurveData_ (x.VerticalCurveData_, f, this),
  SuperelevationData_ (x.SuperelevationData_, f, this),
  IndividualStations_ (x.IndividualStations_, f, this),
  StationRanges_ (x.StationRanges_, f, this),
  SkewLines_ (x.SkewLines_, f, this),
  version_ (x.version_, f, this)
{
}

Curvel::
Curvel (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  UnitsDeclaration_ (f, this),
  VerticalCurveData_ (f, this),
  SuperelevationData_ (f, this),
  IndividualStations_ (f, this),
  StationRanges_ (f, this),
  SkewLines_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
    this->parse (p, f);
  }
}

void Curvel::
parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    // UnitsDeclaration
    //
    if (n.name () == L"UnitsDeclaration" && n.namespace_ () == L"http://www.wsdot.wa.gov/OpenBridgeML/Units")
    {
      ::std::auto_ptr< UnitsDeclaration_type > r (
        UnitsDeclaration_traits::create (i, f, this));

      if (!this->UnitsDeclaration_)
      {
        this->UnitsDeclaration_.set (r);
        continue;
      }
    }

    // VerticalCurveData
    //
    if (n.name () == L"VerticalCurveData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VerticalCurveData_type > r (
        VerticalCurveData_traits::create (i, f, this));

      if (!VerticalCurveData_.present ())
      {
        this->VerticalCurveData_.set (r);
        continue;
      }
    }

    // SuperelevationData
    //
    if (n.name () == L"SuperelevationData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SuperelevationData_type > r (
        SuperelevationData_traits::create (i, f, this));

      if (!this->SuperelevationData_)
      {
        this->SuperelevationData_.set (r);
        continue;
      }
    }

    // IndividualStations
    //
    if (n.name () == L"IndividualStations" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IndividualStations_type > r (
        IndividualStations_traits::create (i, f, this));

      if (!this->IndividualStations_)
      {
        this->IndividualStations_.set (r);
        continue;
      }
    }

    // StationRanges
    //
    if (n.name () == L"StationRanges" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< StationRanges_type > r (
        StationRanges_traits::create (i, f, this));

      if (!this->StationRanges_)
      {
        this->StationRanges_.set (r);
        continue;
      }
    }

    // SkewLines
    //
    if (n.name () == L"SkewLines" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SkewLines_type > r (
        SkewLines_traits::create (i, f, this));

      if (!this->SkewLines_)
      {
        this->SkewLines_.set (r);
        continue;
      }
    }

    break;
  }

  if (!VerticalCurveData_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< wchar_t > (
      L"VerticalCurveData",
      L"");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (i));

    if (n.name () == L"version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version_.set (version_default_value ());
  }
}

Curvel* Curvel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Curvel (*this, f, c);
}

Curvel::
~Curvel ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Curvel >
Curvel_ (const ::std::wstring& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< wchar_t > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (const ::std::wstring& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< wchar_t > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (const ::std::wstring& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< wchar_t > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Curvel_ (isrc, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Curvel_ (isrc, h, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Curvel_ (isrc, h, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         const ::std::wstring& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Curvel_ (isrc, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         const ::std::wstring& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Curvel_ (isrc, h, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::std::istream& is,
         const ::std::wstring& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Curvel_ (isrc, h, f, p);
}

::std::auto_ptr< ::Curvel >
Curvel_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< wchar_t > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< wchar_t > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< wchar_t > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< wchar_t > ();

  ::std::auto_ptr< ::Curvel > r (
    ::Curvel_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Curvel >
Curvel_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Curvel > r (
      ::Curvel_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< wchar_t > n (
    ::xsd::cxx::xml::dom::name< wchar_t > (e));

  if (n.name () == L"Curvel" &&
      n.namespace_ () == L"")
  {
    ::std::auto_ptr< ::Curvel > r (
      ::xsd::cxx::tree::traits< ::Curvel, wchar_t >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
    n.name (),
    n.namespace_ (),
    L"Curvel",
    L"");
}

::std::auto_ptr< ::Curvel >
Curvel_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< wchar_t > n (
    ::xsd::cxx::xml::dom::name< wchar_t > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == L"Curvel" &&
      n.namespace_ () == L"")
  {
    ::std::auto_ptr< ::Curvel > r (
      ::xsd::cxx::tree::traits< ::Curvel, wchar_t >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
    n.name (),
    n.namespace_ (),
    L"Curvel",
    L"");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
Curvel_ (::std::ostream& o,
         const ::Curvel& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));

  ::xsd::cxx::tree::error_handler< wchar_t > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
  }
}

void
Curvel_ (::std::ostream& o,
         const ::Curvel& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< wchar_t > ();
  }
}

void
Curvel_ (::std::ostream& o,
         const ::Curvel& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< wchar_t > ();
  }
}

void
Curvel_ (::xercesc::XMLFormatTarget& t,
         const ::Curvel& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));

  ::xsd::cxx::tree::error_handler< wchar_t > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
  }
}

void
Curvel_ (::xercesc::XMLFormatTarget& t,
         const ::Curvel& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< wchar_t > ();
  }
}

void
Curvel_ (::xercesc::XMLFormatTarget& t,
         const ::Curvel& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::wstring& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Curvel_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< wchar_t > ();
  }
}

void
Curvel_ (::xercesc::DOMDocument& d,
         const ::Curvel& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< wchar_t > n (
    ::xsd::cxx::xml::dom::name< wchar_t > (e));

  if (n.name () == L"Curvel" &&
      n.namespace_ () == L"")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"Curvel",
      L"");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Curvel_ (const ::Curvel& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< wchar_t > (
      L"Curvel",
      L"",
      m, f));

  ::Curvel_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const VerticalCurveDataType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // g1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"g1",
        e));

    s << ::xml_schema::as_double(i.g1 ());
  }

  // g2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"g2",
        e));

    s << ::xml_schema::as_double(i.g2 ());
  }

  // PVIStation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"PVIStation",
        e));

    s << i.PVIStation ();
  }

  // PVIElevation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"PVIElevation",
        e));

    s << i.PVIElevation ();
  }

  // Length
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Length",
        e));

    s << i.Length ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const SuperelevationDataType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ProfileGradeOffset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"ProfileGradeOffset",
        e));

    s << i.ProfileGradeOffset ();
  }

  // CrownSlope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"CrownSlope",
        e));

    s << i.CrownSlope ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const CrownSlopeType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SuperelevationProfilePoint
  //
  for (CrownSlopeType::SuperelevationProfilePoint_const_iterator
       b (i.SuperelevationProfilePoint ().begin ()), n (i.SuperelevationProfilePoint ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"SuperelevationProfilePoint",
        e));

    s << *b;
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const SuperelevationProfilePointType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Station
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Station",
        e));

    s << i.Station ();
  }

  // LeftSlope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"LeftSlope",
        e));

    s << ::xml_schema::as_double(i.LeftSlope ());
  }

  // RightSlope
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"RightSlope",
        e));

    s << ::xml_schema::as_double(i.RightSlope ());
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const IndividualStationsType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IndividualStation
  //
  for (IndividualStationsType::IndividualStation_const_iterator
       b (i.IndividualStation ().begin ()), n (i.IndividualStation ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"IndividualStation",
        e));

    s << *b;
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const IndividualStationType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Station
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Station",
        e));

    s << i.Station ();
  }

  // Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Offset",
        e));

    s << i.Offset ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const StationRangesType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // StationRange
  //
  for (StationRangesType::StationRange_const_iterator
       b (i.StationRange ().begin ()), n (i.StationRange ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"StationRange",
        e));

    s << *b;
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const StationRangeType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // StartStation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"StartStation",
        e));

    s << i.StartStation ();
  }

  // EndStation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"EndStation",
        e));

    s << i.EndStation ();
  }

  // NumSpaces
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"NumSpaces",
        e));

    s << i.NumSpaces ();
  }

  // Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Offset",
        e));

    s << i.Offset ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const SkewLinesType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SkewLine
  //
  for (SkewLinesType::SkewLine_const_iterator
       b (i.SkewLine ().begin ()), n (i.SkewLine ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"SkewLine",
        e));

    s << *b;
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const OffsetType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const OffsetType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const OffsetType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const SkewAngleType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const SkewAngleType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const SkewAngleType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const SkewLineType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Station
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Station",
        e));

    s << i.Station ();
  }

  // OffsetType
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"OffsetType",
        e));

    s << i.OffsetType ();
  }

  // Offset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Offset",
        e));

    s << i.Offset ();
  }

  // SkewAngle
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"SkewAngle",
        e));

    s << i.SkewAngle ();
  }

  // Radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"Radius",
        e));

    s << i.Radius ();
  }

  // CrownOffset
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"CrownOffset",
        e));

    s << i.CrownOffset ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const Curvel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // UnitsDeclaration
  //
  if (i.UnitsDeclaration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"UnitsDeclaration",
        L"http://www.wsdot.wa.gov/OpenBridgeML/Units",
        e));

    s << *i.UnitsDeclaration ();
  }

  // VerticalCurveData
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"VerticalCurveData",
        e));

    s << i.VerticalCurveData ();
  }

  // SuperelevationData
  //
  if (i.SuperelevationData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"SuperelevationData",
        e));

    s << *i.SuperelevationData ();
  }

  // IndividualStations
  //
  if (i.IndividualStations ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"IndividualStations",
        e));

    s << *i.IndividualStations ();
  }

  // StationRanges
  //
  if (i.StationRanges ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"StationRanges",
        e));

    s << *i.StationRanges ();
  }

  // SkewLines
  //
  if (i.SkewLines ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        L"SkewLines",
        e));

    s << *i.SkewLines ();
  }

  // version
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        L"version",
        e));

    a << ::xml_schema::as_decimal(i.version ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

